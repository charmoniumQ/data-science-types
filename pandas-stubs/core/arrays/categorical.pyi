from typing import Dict, Hashable, List, Type, Union, cast
from pandas.core.base import PandasObject
from pandas.dtypes.dtypes import _DtypeObj


class Categorical(NDArrayBackedExtensionArray, PandasObject):
    def __init__(
        self, values: List[Any], categories: Optional[Index]=None, ordered: bool=..., dtype: Optional[_DtypeObj]=None
    ) -> None: ...

    @property
    def categories(self): ...

    @property
    def ordered(self) -> Ordered: ...

    @property
    def dtype(self) -> CategoricalDtype: ...

    def astype(self, dtype: Dtype, copy: bool = True) -> ArrayLike: ...

    def itemsize(self) -> int:
        """
        return the size of a single category
        """
        return self.categories.itemsize

    def tolist(self) -> List[Scalar]:
        """
        Return a list of the values.

        These are each a scalar type, which is a Python scalar
        (for str, int, float) or a pandas scalar
        (for Timestamp/Timedelta/Interval/Period)
        """
        return list(self)

    to_list = tolist

    @classmethod
    def from_codes(cls, codes, categories=None, ordered=None, dtype=None): ...

    @property
    def codes(self) -> np.ndarray: ...

    def set_ordered(self, value, inplace=False): ...

    def as_ordered(self, inplace=False): ...

    def as_unordered(self, inplace=False): ...

    def set_categories(self, new_categories, ordered=None, rename=False, inplace=False): ...

    def rename_categories(self, new_categories, inplace=False): ...

    def reorder_categories(self, new_categories, ordered=None, inplace=False): ...

    def add_categories(self, new_categories, inplace=False): ...

    def remove_categories(self, removals, inplace=False): ...

    def remove_unused_categories(self, inplace=False): ...

    def map(self, mapper): ...

    # __eq__ = _cat_compare_op(operator.eq)
    # __ne__ = _cat_compare_op(operator.ne)
    # __lt__ = _cat_compare_op(operator.lt)
    # __gt__ = _cat_compare_op(operator.gt)
    # __le__ = _cat_compare_op(operator.le)
    # __ge__ = _cat_compare_op(operator.ge)

    def shift(self, periods, fill_value=None): ...

    @property
    def nbytes(self) -> int: ...

    def memory_usage(self, deep=False) -> int: ...

    def searchsorted(self, value, side="left", sorter=None): ...

    def isna(self): ...

    isnull = isna

    def notna(self): ...

    notnull = notna

    def dropna(self): ...

    def value_counts(self, dropna=True): ...

    def check_for_ordered(self, op): ...

    def argsort(self, ascending=True, kind="quicksort", **kwargs): ...

    def sort_values(
        self, inplace: bool = False, ascending: bool = True, na_position: str = "last",
    ): ...

    def view(self, dtype=None): ...

    def to_dense(self): ...

    def fillna(self, value=None, method=None, limit=None): ...

    def take(self: _T, indexer, allow_fill: bool = False, fill_value=None) -> _T: ...
    def take_nd(self, indexer, allow_fill: bool = False, fill_value=None): ...
    def __iter__(self): ...

    def __contains__(self, key) -> bool: ...


    def __getitem__(self, key): ...

    def __setitem__(self, key, value): ...

    def min(self, skipna=True, **kwargs): ...

    def max(self, skipna=True, **kwargs): ...

    def mode(self, dropna=True): ...

    def unique(self): ...

    def equals(self, other): ...

    def is_dtype_equal(self, other): ...

    def describe(self): ...

    def isin(self, values): ...

    def replace(self, to_replace, value, inplace: bool = False): ...
